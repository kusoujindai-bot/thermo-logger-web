<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Thermo Logger (Web)</title>

<!-- CDNãƒ©ã‚¤ãƒ–ãƒ©ãƒª -->
<!-- Tesseract.js -->
<script src="https://unpkg.com/tesseract.js@2.1.5/dist/tesseract.min.js"></script>
<!-- JSZip & FileSaver -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

<style>
  html, body {
  height: 100%;
  margin: 0;
  overflow: hidden; /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç¦æ­¢ */
  font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif;
}

h1 {
  font-size: 16px;
  margin: 4px 0;
  text-align: center;
}

#container {
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  align-items: stretch;
  height: 100vh; /* ç”»é¢å…¨ä½“ã«åã‚ã‚‹ */
  padding: 6px;
  box-sizing: border-box;
  gap: 4px;
}

/* ã‚«ãƒ¡ãƒ©ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆä¸ŠåŠåˆ†ï¼‰ */
#previewWrap {
  position: relative;
  flex: 0 0 42vh; /* ä¸ŠåŠåˆ†ã‚’ã‚«ãƒ¡ãƒ©é ˜åŸŸã« */
  background: #000;
  border-radius: 6px;
  overflow: hidden;
  max-width: 100%;
}

#video, #overlay {
  width: 100%;
  height: 100%;
  object-fit: cover;
  touch-action: none;
}

/* ğŸ‘‡ã“ã‚Œã‚’è¿½åŠ  */
#overlay {
  position: absolute;
  left: 0;
  top: 0;
  z-index: 10;
}


/* ãƒœã‚¿ãƒ³ã‚„è¨­å®š */
.controls {
  flex: 0 0 auto;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  align-items: center;
  gap: 6px;
}

label {
  font-size: 12px;
}

input[type=number] {
  width: 64px;
  padding: 4px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

button {
  padding: 6px 10px;
  border-radius: 6px;
  border: 0;
  background: #0066ff;
  color: #fff;
}

button.secondary {
  background: #666;
}

/* é€²è¡ŒçŠ¶æ³ãƒãƒ¼ */
#progressBar {
  height: 8px;
  background: #eee;
  border-radius: 6px;
  overflow: hidden;
}
#progressFill {
  height: 100%;
  width: 0%;
  background: #2ecc71;
}

/* OCRãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼‹ãƒ­ã‚° */
.row {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  flex: 1;
  gap: 4px;
  overflow: hidden;
}

#cropPreview {
  width: 100px;
  height: 80px;
  border: 1px solid #ddd;
}

#log {
  flex: 1;
  height: 100%;
  background: #f7f7f7;
  padding: 4px;
  border-radius: 6px;
  font-family: monospace;
  font-size: 12px;
  overflow-y: auto;
  white-space: pre-wrap;
}

/* è£œè¶³æ–‡ */
.hint {
  font-size: 11px;
  color: #666;
  text-align: center;
}

/* æ¨ªå‘ã or PCã§ã¯ã‚‚ã†å°‘ã—åºƒã’ã‚‹ */
@media (min-width: 800px) {
  #previewWrap { flex: 0 0 50vh; }
}

</style>
</head>
<body>
<div id="container">
  <h1>Thermo Logger â€” Webç‰ˆï¼ˆCSVå‡ºåŠ›ï¼‰</h1>

  <div id="previewWrap">
    <video id="video" autoplay playsinline></video>
    <canvas id="overlay"></canvas>
  </div>

  <div class="controls">
    <label>æ’®å½±é–“éš”ï¼ˆç§’ï¼‰
      <input id="intervalSec" type="number" min="1" value="5">
    </label>

    <label>æ’®å½±æ™‚é–“ï¼ˆåˆ†ã€æœ€å¤§60ï¼‰
      <input id="durationMin" type="number" min="1" max="60" value="1">
    </label>

    <button id="startBtn">æ’®å½±é–‹å§‹</button>
    <button id="stopBtn" class="secondary" disabled>åœæ­¢</button>

    <label><input id="wakeLock" type="checkbox"> ã‚¹ãƒªãƒ¼ãƒ—æŠ‘æ­¢ï¼ˆWakeLockï¼‰</label>
    <button id="downloadBtn" class="secondary">çµæœã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
  </div>

  <div class="row">
    <div id="status">æº–å‚™å®Œäº†</div>
    <div style="flex:1"></div>
    <div class="hint">é–‹å§‹æ™‚ç‚¹ï¼ˆ0ç§’ï¼‰ã‚’å¿…ãšæ’®å½±ã—ã¾ã™ã€‚</div>
  </div>

  <div id="progressBar"><div id="progressFill"></div></div>

  <div class="row">
    <div>
      <div>OCRåˆ‡ã‚Šå‡ºã—ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆå¸¸æ™‚æ›´æ–°ï¼‰</div>
      <canvas id="cropPreview" width="200" height="120"></canvas>
    </div>

    <div style="flex:1">
      <div>ãƒ­ã‚°</div>
      <div id="log"></div>
    </div>
  </div>

  <div class="hint">â€» ãƒ–ãƒ©ã‚¦ã‚¶ãŒã‚«ãƒ¡ãƒ©ã‚¢ã‚¯ã‚»ã‚¹ã‚’æ±‚ã‚ã¾ã™ã€‚ã‚¹ãƒãƒ›ã®ã‚µãƒ¼ãƒ¢ã‚«ãƒ¡ãƒ©è¡¨ç¤ºã‚’ã‚¹ãƒãƒ›ã‚«ãƒ¡ãƒ©ã§æ’®å½±ã—ã¦ãã ã•ã„ã€‚æ’®å½±ç”»åƒã¨OCRåˆ‡ã‚Šå‡ºã—ã‚’CSVã¨ç”»åƒã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚</div>
</div>

<!-- hidden canvas for capture -->
<canvas id="captureCanvas" style="display:none;"></canvas>

<!-- small beep sound -->
<audio id="beep">
  <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=" type="audio/wav">
</audio>

<script>
/*
  Thermo Logger (Web)
  - intervalSec: ç§’ã”ã¨ã®æ’®å½±é–“éš”
  - durationMin: åˆè¨ˆæ’®å½±æ™‚é–“ï¼ˆåˆ†, max60)
  - 0ç§’æ™‚ã«å³æ’®å½±
  - é«˜ç²¾åº¦ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ï¼ˆãƒ‰ãƒªãƒ•ãƒˆè£œæ­£ï¼‰
  - ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒçŸ©å½¢é¸æŠã§OCRé ˜åŸŸã‚’æŒ‡å®šï¼ˆãƒ‰ãƒ©ãƒƒã‚°ï¼ã‚¿ãƒƒãƒ—ï¼‰
  - åˆ‡ã‚Šå‡ºã—ç”»åƒã‚’ä¿å­˜ã€OCRã‚’å®Ÿè¡Œï¼ˆTesseract.jsï¼‰
  - æ’®å½±å¾Œã€CSV ã¨ åˆ‡ã‚Šå‡ºã—ç”»åƒ ã‚’ ZIP ã«ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å¯èƒ½
*/

const video = document.getElementById('video');
const overlay = document.getElementById('overlay');
const overlayCtx = overlay.getContext('2d');
const captureCanvas = document.getElementById('captureCanvas');
const cropPreview = document.getElementById('cropPreview');
const cropCtx = cropPreview.getContext('2d');

const intervalInput = document.getElementById('intervalSec');
const durationInput = document.getElementById('durationMin');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');
const progressFill = document.getElementById('progressFill');
const downloadBtn = document.getElementById('downloadBtn');
const wakeLockCheckbox = document.getElementById('wakeLock');
const beep = document.getElementById('beep');

let stream = null;
let startTime = null;
let stopTime = null;
let scheduledTimer = null;
let wakeLock = null;
let isRunning = false;
let intervalSec = 5;
let durationMin = 1;
let elapsedCount = 0;

// data storage
const records = []; // {elapsedSec, temp (number|null), imgFilename, imgBlob}
let captureIndex = 0;

// OCR region (relative coords normalized 0..1)
let region = {x:0.58,y:0.35,w:0.28,h:0.18}; // åˆæœŸå€¤ï¼ˆå³ä¸Šã‚ãŸã‚Šï¼‰ - ãƒ¦ãƒ¼ã‚¶ãƒ¼ã§æ›´æ–°å¯

// mouse/touch state for selection
let selecting = false;
let selStart = null;
let selRect = null;

async function initCamera(){
  try {
    stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio:false });
    video.srcObject = stream;
    await video.play();
    resizeOverlay();
    window.addEventListener('resize', resizeOverlay);
    window.addEventListener('scroll', resizeOverlay); // â†â˜…ã“ã®1è¡Œã‚’è¿½åŠ ï¼
    drawOverlay(); // initial draw
    status('ã‚«ãƒ¡ãƒ©èµ·å‹•');
  } catch (e) {
    status('ã‚«ãƒ¡ãƒ©ã®ã‚¢ã‚¯ã‚»ã‚¹ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + e.message);
    console.error(e);
  }
}

// resize overlay canvas to match video display size
function resizeOverlay(){
  const rect = video.getBoundingClientRect();
  overlay.width = rect.width;
  overlay.height = rect.height;
  // overlay.style.left = rect.left + 'px'; â†å‰Šé™¤
  // overlay.style.top = rect.top + 'px'; â†å‰Šé™¤
  drawOverlay();
}

// draw selection rectangle on overlay continuously
function drawOverlay(){
  overlayCtx.clearRect(0,0,overlay.width,overlay.height);
  // draw translucent mask
  overlayCtx.fillStyle = 'rgba(0,0,0,0.25)';
  overlayCtx.fillRect(0,0,overlay.width,overlay.height);
  // compute pixel region
  const r = regionToPixels(region, overlay.width, overlay.height);
  // clear the region area
  overlayCtx.clearRect(r.x,r.y,r.w,r.h);
  // draw border
  overlayCtx.strokeStyle = '#00FF77';
  overlayCtx.lineWidth = 2;
  overlayCtx.strokeRect(r.x + 0.5, r.y + 0.5, r.w -1, r.h -1);
  // label
  overlayCtx.font = '14px sans-serif';
  overlayCtx.fillStyle = '#00FF77';
  overlayCtx.fillText('OCRé ˜åŸŸ', r.x+6, r.y+18);
  // if user is drawing selection
  if (selRect) {
    overlayCtx.strokeStyle = '#FFD54D';
    overlayCtx.strokeRect(selRect.x, selRect.y, selRect.w, selRect.h);
  }
  requestAnimationFrame(()=>{});
}

function regionToPixels(r, width, height){
  return {
    x: Math.round(r.x * width),
    y: Math.round(r.y * height),
    w: Math.round(r.w * width),
    h: Math.round(r.h * height)
  };
}

function pixelsToRegion(p, width, height){
  return {
    x: p.x / width,
    y: p.y / height,
    w: p.w / width,
    h: p.h / height
  };
}

// selection events (pointer) ã‚¹ãƒãƒ›å¯¾å¿œãƒ»ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜²æ­¢ç‰ˆ
overlay.addEventListener('pointerdown', (e) => {
  e.preventDefault(); // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚„ã‚ºãƒ¼ãƒ ã‚’é˜²æ­¢
  selecting = true;
  const rect = overlay.getBoundingClientRect();
  selStart = { x: e.clientX - rect.left, y: e.clientY - rect.top };
  selRect = { x: selStart.x, y: selStart.y, w: 0, h: 0 };
});

overlay.addEventListener('pointermove', (e) => {
  if (!selecting) return;
  e.preventDefault(); // â†ã“ã“ã‚‚é‡è¦
  const rect = overlay.getBoundingClientRect();
  const px = e.clientX - rect.left;
  const py = e.clientY - rect.top;
  selRect.w = px - selStart.x;
  selRect.h = py - selStart.y;
  // normalize so w,h positive
  if (selRect.w < 0) { selRect.x = selStart.x + selRect.w; selRect.w = Math.abs(selRect.w); } else { selRect.x = selStart.x; }
  if (selRect.h < 0) { selRect.y = selStart.y + selRect.h; selRect.h = Math.abs(selRect.h); } else { selRect.y = selStart.y; }
  drawOverlay();
});

overlay.addEventListener('pointerup', (e) => {
  e.preventDefault();
  if (!selecting) return;
  selecting = false;
  // commit region
  const rect = overlay.getBoundingClientRect();
  const p = { x: selRect.x, y: selRect.y, w: selRect.w, h: selRect.h };
  region = pixelsToRegion(p, overlay.width, overlay.height);
  selRect = null;
  drawOverlay();
});


// helper status/log
function status(text){
  statusEl.textContent = text;
  log(text);
}
function log(text){
  const t = new Date().toLocaleTimeString() + '  ' + text;
  logEl.textContent = t + '\n' + logEl.textContent;
}

// high-precision scheduler: uses next scheduled absolute times to avoid drift
async function startCapture(){
  intervalSec = Math.max(1, parseInt(intervalInput.value));
  durationMin = Math.min(60, Math.max(0.0167, parseInt(durationInput.value))); // min ~1s
  const totalSeconds = durationMin * 60;
  startBtn.disabled = true;
  stopBtn.disabled = false;
  downloadBtn.disabled = true;
  isRunning = true;
  records.length = 0;
  captureIndex = 0;
  startTime = performance.now();
  const startUnix = Date.now();
  stopTime = startTime + totalSeconds * 1000;
  status('æ’®å½±ä¸­ï¼ˆé–‹å§‹ï¼‰');
  elapsedCount = 0;
  updateProgress(); // immediate

  // wake lock
  if(wakeLockCheckbox.checked && 'wakeLock' in navigator){
    try {
      wakeLock = await navigator.wakeLock.request('screen');
      log('WakeLockå–å¾—');
    } catch(e){ log('WakeLock ã‚¨ãƒ©ãƒ¼:' + e.message); }
  }

  // ensure capture at t=0 immediately
  await doCapture(0, startUnix);

  // schedule future captures at multiples of intervalSec
  let n = 1;
  const loop = async ()=>{
    if(!isRunning) return;
    const targetMs = startTime + n * intervalSec * 1000;
    const now = performance.now();
    const delay = Math.max(0, targetMs - now);
    if(now >= stopTime){
      stopCapture();
      return;
    }
    scheduledTimer = setTimeout(async ()=>{
      // safety check: if passed stopTime stop
      if(performance.now() > stopTime + 50) { stopCapture(); return; }
      const elapsedSec = Math.round((performance.now() - startTime)/1000);
      await doCapture(elapsedSec, startUnix);
      n++;
      loop();
    }, delay);
  };
  loop();
}

// capture one frame, crop, OCR, store result
async function doCapture(elapsedSec, startUnix){
  try {
    // draw video frame to captureCanvas at its video resolution
    const videoSettings = stream.getVideoTracks()[0].getSettings();
    const vW = video.videoWidth || (videoSettings && videoSettings.width) || overlay.width;
    const vH = video.videoHeight || (videoSettings && videoSettings.height) || overlay.height;

    captureCanvas.width = vW;
    captureCanvas.height = vH;
    const cctx = captureCanvas.getContext('2d');
    // draw the current video frame (scale to video resolution)
    cctx.drawImage(video, 0, 0, vW, vH);

    // compute crop in pixels relative to video resolution
    const r = {x: Math.round(region.x * vW), y: Math.round(region.y * vH), w: Math.round(region.w * vW), h: Math.round(region.h * vH)};
    // ensure bounds
    r.x = Math.max(0, Math.min(r.x, vW-1));
    r.y = Math.max(0, Math.min(r.y, vH-1));
    r.w = Math.max(1, Math.min(r.w, vW - r.x));
    r.h = Math.max(1, Math.min(r.h, vH - r.y));

    // create crop canvas blob
    const cropCanvas = document.createElement('canvas');
    cropCanvas.width = r.w;
    cropCanvas.height = r.h;
    const cropCtxLocal = cropCanvas.getContext('2d');
    cropCtxLocal.drawImage(captureCanvas, r.x, r.y, r.w, r.h, 0, 0, r.w, r.h);

    // update preview scaled to preview canvas
    cropCtx.clearRect(0,0,cropPreview.width,cropPreview.height);
    // keep aspect
    const ar = r.w / r.h;
    const targetH = cropPreview.height;
    const targetW = Math.round(targetH * ar);
    cropCtx.drawImage(cropCanvas, 0, 0, targetW, targetH);

    // save image blob
    const blob = await new Promise(res => cropCanvas.toBlob(res, 'image/png'));

    // run OCR on crop (async) but don't block UI - still wait to store result for CSV
    status(`æ’®å½±: ${elapsedSec}s â†’ OCRå®Ÿè¡Œä¸­`);
    const t0 = performance.now();
    // Tesseract.js usage
    let text = '';
    try {
      // using Tesseract v2 CDN; lightweight options
      const worker = Tesseract.createWorker({logger: m => {}});
      await worker.load();
      await worker.loadLanguage('eng+osd'); // english helps numeric recognition; OSD optional
      await worker.initialize('eng+osd');
      // recognize - convert crop canvas to blob URL
      const dataUrl = cropCanvas.toDataURL('image/png');
      const res = await worker.recognize(dataUrl);
      text = res.data && res.data.text ? res.data.text : '';
      await worker.terminate();
    } catch(e) {
      console.warn('OCRã‚¨ãƒ©ãƒ¼', e);
      text = '';
    }
    const t1 = performance.now();

    // extract number (æ¸©åº¦) using regex - allow digits, decimal, optional degree/c symbol
    const cleaned = text.replace(/\s+/g,' ');
    const m = cleaned.match(/(-?\d+(\.\d+)?)/);
    let temp = null;
    if(m){
      temp = parseFloat(m[1]);
    }

    const filename = `capture_${String(captureIndex).padStart(4,'0')}_${elapsedSec}s.png`;
    captureIndex++;

    records.push({elapsedSec, temp, imgFilename: filename, imgBlob: blob, rawOCR: cleaned});

    log(`ä¿å­˜: ${filename}  ${elapsedSec}s  temp:${temp!==null?temp+'Â°C':'(æœªæ¤œå‡º)'}  OCR:${JSON.stringify(cleaned).slice(0,40)}`);
    status(`æ’®å½± ${elapsedSec}s ï¼ˆOCR ${Math.round(t1-t0)}msï¼‰`);

    // update progress & indicator
    updateProgress();

  } catch(e){
    console.error('capture error', e);
    log('æ’®å½±å¤±æ•—:' + e.message);
  }
}

function updateProgress(){
  if(!isRunning){
    progressFill.style.width = '0%';
    return;
  }
  const totalMs = (durationInput.value*60*1000);
  const elapsedMs = Math.min(performance.now() - startTime, totalMs);
  const pct = Math.round( (elapsedMs / totalMs) * 100 );
  progressFill.style.width = pct + '%';
  const elapsedSec = Math.floor(elapsedMs / 1000);
  status(`çµŒé: ${formatTime(elapsedSec)} / ${formatTime(Math.floor(totalMs/1000))} (${pct}%)`);
}

// stop capture and finish
function stopCapture(){
  if(!isRunning) return;
  isRunning = false;
  startBtn.disabled = false;
  stopBtn.disabled = true;
  if(scheduledTimer) clearTimeout(scheduledTimer);
  // release wake lock
  if(wakeLock){
    try{ wakeLock.release(); }catch(e){}
    wakeLock = null;
  }
  status('æ’®å½±çµ‚äº†');
  beep.play().catch(()=>{ /* some browsers require user gesture */ });
  downloadBtn.disabled = false;
  log('æ’®å½±ãŒå®Œäº†ã—ã¾ã—ãŸã€‚ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚');
}

// format time mm:ss
function formatTime(s){
  const mm = String(Math.floor(s/60)).padStart(2,'0');
  const ss = String(s%60).padStart(2,'0');
  return `${mm}:${ss}`;
}

// download results as ZIP with CSV + images
async function downloadResults(){
  if(records.length === 0) { alert('è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“'); return; }
  downloadBtn.disabled = true;
  status('ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆä¸­...');
  const zip = new JSZip();
  // CSV header: elapsedSec, temperature, imageFilename, rawOCR
  let csv = 'elapsedSec,temperature_C,imageFilename,rawOCR\n';
  for(const rec of records){
    // append csv line
    const temp = (rec.temp !== null) ? rec.temp : '';
    const safeOCR = '"' + (rec.rawOCR ? rec.rawOCR.replace(/"/g,'""') : '') + '"';
    csv += `${rec.elapsedSec},${temp},${rec.imgFilename},${safeOCR}\n`;
    // add image blob to zip
    zip.file(rec.imgFilename, rec.imgBlob);
  }
  zip.file('data.csv', csv);

  const blob = await zip.generateAsync({type:'blob'});
  saveAs(blob, `thermo_data_${new Date().toISOString().replace(/[:.]/g,'-')}.zip`);
  status('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†');
  downloadBtn.disabled = false;
}

// UI buttons
startBtn.addEventListener('click', async ()=>{
  // validate inputs
  const iv = parseInt(intervalInput.value);
  const dm = parseInt(durationInput.value);
  if(isNaN(iv) || iv < 1){ alert('æ’®å½±é–“éš”ã¯1ç§’ä»¥ä¸Šã§æŒ‡å®šã—ã¦ãã ã•ã„'); return; }
  if(isNaN(dm) || dm < 1 || dm > 60){ alert('æ’®å½±æ™‚é–“ã¯1ã€œ60åˆ†ã§æŒ‡å®šã—ã¦ãã ã•ã„'); return; }
  // ensure camera ready
  if(!stream){ await initCamera(); }
  startCapture();
});
stopBtn.addEventListener('click', ()=>{ stopCapture(); });
downloadBtn.addEventListener('click', ()=>{ downloadResults(); });

// try to init camera on load (may trigger permission prompt)
initCamera();

// WakeLock: re-request if released (visibility change)
if('wakeLock' in navigator){
  document.addEventListener('visibilitychange', async ()=>{
    if(wakeLockCheckbox.checked && isRunning && document.visibilityState === 'visible'){
      try { wakeLock = await navigator.wakeLock.request('screen'); } catch(e){ console.warn(e); }
    }
  });
}

// basic guidance for user
log('æº–å‚™ã§ãã¾ã—ãŸã€‚OCRé ˜åŸŸã¯è¡¨ç¤ºä¸Šã®çŸ©å½¢ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦å¤‰æ›´ã§ãã¾ã™ã€‚é–‹å§‹ãƒœã‚¿ãƒ³ã§0ç§’ç›®ã®æ’®å½±ãŒè¡Œã‚ã‚Œã¾ã™ã€‚');
</script>
</body>
</html>