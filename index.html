<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Thermo Logger (Web)</title>

<!-- CDNライブラリ -->
<!-- Tesseract.js -->
<script src="https://unpkg.com/tesseract.js@2.1.5/dist/tesseract.min.js"></script>
<!-- JSZip & FileSaver -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

<style>
  html, body {
  height: 100%;
  margin: 0;
  overflow: hidden; /* スクロール禁止 */
  font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif;
}

h1 {
  font-size: 16px;
  margin: 4px 0;
  text-align: center;
}

#container {
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  align-items: stretch;
  height: 100vh; /* 画面全体に収める */
  padding: 6px;
  box-sizing: border-box;
  gap: 4px;
}

/* カメラプレビュー（上半分） */
#previewWrap {
  position: relative;
  flex: 0 0 42vh; /* 上半分をカメラ領域に */
  background: #000;
  border-radius: 6px;
  overflow: hidden;
  max-width: 100%;
}

#video, #overlay {
  width: 100%;
  height: 100%;
  object-fit: cover;
  touch-action: none; /* スワイプ時スクロール防止 */
}

/* ボタンや設定 */
.controls {
  flex: 0 0 auto;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  align-items: center;
  gap: 6px;
}

label {
  font-size: 12px;
}

input[type=number] {
  width: 64px;
  padding: 4px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

button {
  padding: 6px 10px;
  border-radius: 6px;
  border: 0;
  background: #0066ff;
  color: #fff;
}

button.secondary {
  background: #666;
}

/* 進行状況バー */
#progressBar {
  height: 8px;
  background: #eee;
  border-radius: 6px;
  overflow: hidden;
}
#progressFill {
  height: 100%;
  width: 0%;
  background: #2ecc71;
}

/* OCRプレビュー＋ログ */
.row {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  flex: 1;
  gap: 4px;
  overflow: hidden;
}

#cropPreview {
  width: 100px;
  height: 80px;
  border: 1px solid #ddd;
}

#log {
  flex: 1;
  height: 100%;
  background: #f7f7f7;
  padding: 4px;
  border-radius: 6px;
  font-family: monospace;
  font-size: 12px;
  overflow-y: auto;
  white-space: pre-wrap;
}

/* 補足文 */
.hint {
  font-size: 11px;
  color: #666;
  text-align: center;
}

/* 横向き or PCではもう少し広げる */
@media (min-width: 800px) {
  #previewWrap { flex: 0 0 50vh; }
}

</style>
</head>
<body>
<div id="container">
  <h1>Thermo Logger — Web版（CSV出力）</h1>

  <div id="previewWrap">
    <video id="video" autoplay playsinline></video>
    <canvas id="overlay"></canvas>
  </div>

  <div class="controls">
    <label>撮影間隔（秒）
      <input id="intervalSec" type="number" min="1" value="5">
    </label>

    <label>撮影時間（分、最大60）
      <input id="durationMin" type="number" min="1" max="60" value="1">
    </label>

    <button id="startBtn">撮影開始</button>
    <button id="stopBtn" class="secondary" disabled>停止</button>

    <label><input id="wakeLock" type="checkbox"> スリープ抑止（WakeLock）</label>
    <button id="downloadBtn" class="secondary">結果をダウンロード</button>
  </div>

  <div class="row">
    <div id="status">準備完了</div>
    <div style="flex:1"></div>
    <div class="hint">開始時点（0秒）を必ず撮影します。</div>
  </div>

  <div id="progressBar"><div id="progressFill"></div></div>

  <div class="row">
    <div>
      <div>OCR切り出しプレビュー（常時更新）</div>
      <canvas id="cropPreview" width="200" height="120"></canvas>
    </div>

    <div style="flex:1">
      <div>ログ</div>
      <div id="log"></div>
    </div>
  </div>

  <div class="hint">※ ブラウザがカメラアクセスを求めます。スマホのサーモカメラ表示をスマホカメラで撮影してください。撮影画像とOCR切り出しをCSVと画像でダウンロードします。</div>
</div>

<!-- hidden canvas for capture -->
<canvas id="captureCanvas" style="display:none;"></canvas>

<!-- small beep sound -->
<audio id="beep">
  <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=" type="audio/wav">
</audio>

<script>
/*
  Thermo Logger (Web)
  - intervalSec: 秒ごとの撮影間隔
  - durationMin: 合計撮影時間（分, max60)
  - 0秒時に即撮影
  - 高精度スケジューリング（ドリフト補正）
  - ユーザーが矩形選択でOCR領域を指定（ドラッグ／タップ）
  - 切り出し画像を保存、OCRを実行（Tesseract.js）
  - 撮影後、CSV と 切り出し画像 を ZIP にしてダウンロード可能
*/

const video = document.getElementById('video');
const overlay = document.getElementById('overlay');
const overlayCtx = overlay.getContext('2d');
const captureCanvas = document.getElementById('captureCanvas');
const cropPreview = document.getElementById('cropPreview');
const cropCtx = cropPreview.getContext('2d');

const intervalInput = document.getElementById('intervalSec');
const durationInput = document.getElementById('durationMin');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');
const progressFill = document.getElementById('progressFill');
const downloadBtn = document.getElementById('downloadBtn');
const wakeLockCheckbox = document.getElementById('wakeLock');
const beep = document.getElementById('beep');

let stream = null;
let startTime = null;
let stopTime = null;
let scheduledTimer = null;
let wakeLock = null;
let isRunning = false;
let intervalSec = 5;
let durationMin = 1;
let elapsedCount = 0;

// data storage
const records = []; // {elapsedSec, temp (number|null), imgFilename, imgBlob}
let captureIndex = 0;

// OCR region (relative coords normalized 0..1)
let region = {x:0.58,y:0.35,w:0.28,h:0.18}; // 初期値（右上あたり） - ユーザーで更新可

// mouse/touch state for selection
let selecting = false;
let selStart = null;
let selRect = null;

async function initCamera(){
  try {
    stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio:false });
    video.srcObject = stream;
    await video.play();
    resizeOverlay();
    window.addEventListener('resize', resizeOverlay);
    window.addEventListener('scroll', resizeOverlay); // ←★この1行を追加！
    drawOverlay(); // initial draw
    status('カメラ起動');
  } catch (e) {
    status('カメラのアクセスに失敗しました: ' + e.message);
    console.error(e);
  }
}

// resize overlay canvas to match video display size
function resizeOverlay(){
  const rect = video.getBoundingClientRect();
  overlay.width = rect.width;
  overlay.height = rect.height;
  overlay.style.left = rect.left + 'px';
  overlay.style.top = rect.top + 'px';
  drawOverlay();
}

// draw selection rectangle on overlay continuously
function drawOverlay(){
  overlayCtx.clearRect(0,0,overlay.width,overlay.height);
  // draw translucent mask
  overlayCtx.fillStyle = 'rgba(0,0,0,0.25)';
  overlayCtx.fillRect(0,0,overlay.width,overlay.height);
  // compute pixel region
  const r = regionToPixels(region, overlay.width, overlay.height);
  // clear the region area
  overlayCtx.clearRect(r.x,r.y,r.w,r.h);
  // draw border
  overlayCtx.strokeStyle = '#00FF77';
  overlayCtx.lineWidth = 2;
  overlayCtx.strokeRect(r.x + 0.5, r.y + 0.5, r.w -1, r.h -1);
  // label
  overlayCtx.font = '14px sans-serif';
  overlayCtx.fillStyle = '#00FF77';
  overlayCtx.fillText('OCR領域', r.x+6, r.y+18);
  // if user is drawing selection
  if (selRect) {
    overlayCtx.strokeStyle = '#FFD54D';
    overlayCtx.strokeRect(selRect.x, selRect.y, selRect.w, selRect.h);
  }
  requestAnimationFrame(()=>{});
}

function regionToPixels(r, width, height){
  return {
    x: Math.round(r.x * width),
    y: Math.round(r.y * height),
    w: Math.round(r.w * width),
    h: Math.round(r.h * height)
  };
}

function pixelsToRegion(p, width, height){
  return {
    x: p.x / width,
    y: p.y / height,
    w: p.w / width,
    h: p.h / height
  };
}

// selection events (pointer) スマホ対応・スクロール防止版
overlay.addEventListener('pointerdown', (e) => {
  e.preventDefault(); // スクロールやズームを防止
  selecting = true;
  const rect = overlay.getBoundingClientRect();
  selStart = { x: e.clientX - rect.left, y: e.clientY - rect.top };
  selRect = { x: selStart.x, y: selStart.y, w: 0, h: 0 };
});

overlay.addEventListener('pointermove', (e) => {
  if (!selecting) return;
  e.preventDefault(); // ←ここも重要
  const rect = overlay.getBoundingClientRect();
  const px = e.clientX - rect.left;
  const py = e.clientY - rect.top;
  selRect.w = px - selStart.x;
  selRect.h = py - selStart.y;
  // normalize so w,h positive
  if (selRect.w < 0) { selRect.x = selStart.x + selRect.w; selRect.w = Math.abs(selRect.w); } else { selRect.x = selStart.x; }
  if (selRect.h < 0) { selRect.y = selStart.y + selRect.h; selRect.h = Math.abs(selRect.h); } else { selRect.y = selStart.y; }
  drawOverlay();
});

overlay.addEventListener('pointerup', (e) => {
  e.preventDefault();
  if (!selecting) return;
  selecting = false;
  // commit region
  const rect = overlay.getBoundingClientRect();
  const p = { x: selRect.x, y: selRect.y, w: selRect.w, h: selRect.h };
  region = pixelsToRegion(p, overlay.width, overlay.height);
  selRect = null;
  drawOverlay();
});


// helper status/log
function status(text){
  statusEl.textContent = text;
  log(text);
}
function log(text){
  const t = new Date().toLocaleTimeString() + '  ' + text;
  logEl.textContent = t + '\n' + logEl.textContent;
}

// high-precision scheduler: uses next scheduled absolute times to avoid drift
async function startCapture(){
  intervalSec = Math.max(1, parseInt(intervalInput.value));
  durationMin = Math.min(60, Math.max(0.0167, parseInt(durationInput.value))); // min ~1s
  const totalSeconds = durationMin * 60;
  startBtn.disabled = true;
  stopBtn.disabled = false;
  downloadBtn.disabled = true;
  isRunning = true;
  records.length = 0;
  captureIndex = 0;
  startTime = performance.now();
  const startUnix = Date.now();
  stopTime = startTime + totalSeconds * 1000;
  status('撮影中（開始）');
  elapsedCount = 0;
  updateProgress(); // immediate

  // wake lock
  if(wakeLockCheckbox.checked && 'wakeLock' in navigator){
    try {
      wakeLock = await navigator.wakeLock.request('screen');
      log('WakeLock取得');
    } catch(e){ log('WakeLock エラー:' + e.message); }
  }

  // ensure capture at t=0 immediately
  await doCapture(0, startUnix);

  // schedule future captures at multiples of intervalSec
  let n = 1;
  const loop = async ()=>{
    if(!isRunning) return;
    const targetMs = startTime + n * intervalSec * 1000;
    const now = performance.now();
    const delay = Math.max(0, targetMs - now);
    if(now >= stopTime){
      stopCapture();
      return;
    }
    scheduledTimer = setTimeout(async ()=>{
      // safety check: if passed stopTime stop
      if(performance.now() > stopTime + 50) { stopCapture(); return; }
      const elapsedSec = Math.round((performance.now() - startTime)/1000);
      await doCapture(elapsedSec, startUnix);
      n++;
      loop();
    }, delay);
  };
  loop();
}

// capture one frame, crop, OCR, store result
async function doCapture(elapsedSec, startUnix){
  try {
    // draw video frame to captureCanvas at its video resolution
    const videoSettings = stream.getVideoTracks()[0].getSettings();
    const vW = video.videoWidth || (videoSettings && videoSettings.width) || overlay.width;
    const vH = video.videoHeight || (videoSettings && videoSettings.height) || overlay.height;

    captureCanvas.width = vW;
    captureCanvas.height = vH;
    const cctx = captureCanvas.getContext('2d');
    // draw the current video frame (scale to video resolution)
    cctx.drawImage(video, 0, 0, vW, vH);

    // compute crop in pixels relative to video resolution
    const r = {x: Math.round(region.x * vW), y: Math.round(region.y * vH), w: Math.round(region.w * vW), h: Math.round(region.h * vH)};
    // ensure bounds
    r.x = Math.max(0, Math.min(r.x, vW-1));
    r.y = Math.max(0, Math.min(r.y, vH-1));
    r.w = Math.max(1, Math.min(r.w, vW - r.x));
    r.h = Math.max(1, Math.min(r.h, vH - r.y));

    // create crop canvas blob
    const cropCanvas = document.createElement('canvas');
    cropCanvas.width = r.w;
    cropCanvas.height = r.h;
    const cropCtxLocal = cropCanvas.getContext('2d');
    cropCtxLocal.drawImage(captureCanvas, r.x, r.y, r.w, r.h, 0, 0, r.w, r.h);

    // update preview scaled to preview canvas
    cropCtx.clearRect(0,0,cropPreview.width,cropPreview.height);
    // keep aspect
    const ar = r.w / r.h;
    const targetH = cropPreview.height;
    const targetW = Math.round(targetH * ar);
    cropCtx.drawImage(cropCanvas, 0, 0, targetW, targetH);

    // save image blob
    const blob = await new Promise(res => cropCanvas.toBlob(res, 'image/png'));

    // run OCR on crop (async) but don't block UI - still wait to store result for CSV
    status(`撮影: ${elapsedSec}s → OCR実行中`);
    const t0 = performance.now();
    // Tesseract.js usage
    let text = '';
    try {
      // using Tesseract v2 CDN; lightweight options
      const worker = Tesseract.createWorker({logger: m => {}});
      await worker.load();
      await worker.loadLanguage('eng+osd'); // english helps numeric recognition; OSD optional
      await worker.initialize('eng+osd');
      // recognize - convert crop canvas to blob URL
      const dataUrl = cropCanvas.toDataURL('image/png');
      const res = await worker.recognize(dataUrl);
      text = res.data && res.data.text ? res.data.text : '';
      await worker.terminate();
    } catch(e) {
      console.warn('OCRエラー', e);
      text = '';
    }
    const t1 = performance.now();

    // extract number (温度) using regex - allow digits, decimal, optional degree/c symbol
    const cleaned = text.replace(/\s+/g,' ');
    const m = cleaned.match(/(-?\d+(\.\d+)?)/);
    let temp = null;
    if(m){
      temp = parseFloat(m[1]);
    }

    const filename = `capture_${String(captureIndex).padStart(4,'0')}_${elapsedSec}s.png`;
    captureIndex++;

    records.push({elapsedSec, temp, imgFilename: filename, imgBlob: blob, rawOCR: cleaned});

    log(`保存: ${filename}  ${elapsedSec}s  temp:${temp!==null?temp+'°C':'(未検出)'}  OCR:${JSON.stringify(cleaned).slice(0,40)}`);
    status(`撮影 ${elapsedSec}s （OCR ${Math.round(t1-t0)}ms）`);

    // update progress & indicator
    updateProgress();

  } catch(e){
    console.error('capture error', e);
    log('撮影失敗:' + e.message);
  }
}

function updateProgress(){
  if(!isRunning){
    progressFill.style.width = '0%';
    return;
  }
  const totalMs = (durationInput.value*60*1000);
  const elapsedMs = Math.min(performance.now() - startTime, totalMs);
  const pct = Math.round( (elapsedMs / totalMs) * 100 );
  progressFill.style.width = pct + '%';
  const elapsedSec = Math.floor(elapsedMs / 1000);
  status(`経過: ${formatTime(elapsedSec)} / ${formatTime(Math.floor(totalMs/1000))} (${pct}%)`);
}

// stop capture and finish
function stopCapture(){
  if(!isRunning) return;
  isRunning = false;
  startBtn.disabled = false;
  stopBtn.disabled = true;
  if(scheduledTimer) clearTimeout(scheduledTimer);
  // release wake lock
  if(wakeLock){
    try{ wakeLock.release(); }catch(e){}
    wakeLock = null;
  }
  status('撮影終了');
  beep.play().catch(()=>{ /* some browsers require user gesture */ });
  downloadBtn.disabled = false;
  log('撮影が完了しました。ダウンロードしてください。');
}

// format time mm:ss
function formatTime(s){
  const mm = String(Math.floor(s/60)).padStart(2,'0');
  const ss = String(s%60).padStart(2,'0');
  return `${mm}:${ss}`;
}

// download results as ZIP with CSV + images
async function downloadResults(){
  if(records.length === 0) { alert('記録がありません'); return; }
  downloadBtn.disabled = true;
  status('ファイルを生成中...');
  const zip = new JSZip();
  // CSV header: elapsedSec, temperature, imageFilename, rawOCR
  let csv = 'elapsedSec,temperature_C,imageFilename,rawOCR\n';
  for(const rec of records){
    // append csv line
    const temp = (rec.temp !== null) ? rec.temp : '';
    const safeOCR = '"' + (rec.rawOCR ? rec.rawOCR.replace(/"/g,'""') : '') + '"';
    csv += `${rec.elapsedSec},${temp},${rec.imgFilename},${safeOCR}\n`;
    // add image blob to zip
    zip.file(rec.imgFilename, rec.imgBlob);
  }
  zip.file('data.csv', csv);

  const blob = await zip.generateAsync({type:'blob'});
  saveAs(blob, `thermo_data_${new Date().toISOString().replace(/[:.]/g,'-')}.zip`);
  status('ダウンロード完了');
  downloadBtn.disabled = false;
}

// UI buttons
startBtn.addEventListener('click', async ()=>{
  // validate inputs
  const iv = parseInt(intervalInput.value);
  const dm = parseInt(durationInput.value);
  if(isNaN(iv) || iv < 1){ alert('撮影間隔は1秒以上で指定してください'); return; }
  if(isNaN(dm) || dm < 1 || dm > 60){ alert('撮影時間は1〜60分で指定してください'); return; }
  // ensure camera ready
  if(!stream){ await initCamera(); }
  startCapture();
});
stopBtn.addEventListener('click', ()=>{ stopCapture(); });
downloadBtn.addEventListener('click', ()=>{ downloadResults(); });

// try to init camera on load (may trigger permission prompt)
initCamera();

// WakeLock: re-request if released (visibility change)
if('wakeLock' in navigator){
  document.addEventListener('visibilitychange', async ()=>{
    if(wakeLockCheckbox.checked && isRunning && document.visibilityState === 'visible'){
      try { wakeLock = await navigator.wakeLock.request('screen'); } catch(e){ console.warn(e); }
    }
  });
}

// basic guidance for user
log('準備できました。OCR領域は表示上の矩形をドラッグして変更できます。開始ボタンで0秒目の撮影が行われます。');
</script>
</body>
</html>